nonterminal varDeclaration, type, idChain, funcDeclaration, globalProg, varAsignation, valueType, asignationChain, paramChain;

terminal COMMA, SEMICOLON, INCREMENT, DECREMENT, EQUALS, GREATEREQUAL, GREATER, QUESTION, LESSEQUAL, LESS, NOTEQUAL, OROR, ANDAND, NOT, ASSIGN, PLUS, MINUS, TIMES, DIVIDE, MODULO, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, COLON, DOT, PLUSEQUAL, MINUSEQUAL, TIMESEQUAL, DIVIDEEQUAL, AND, XOR, OR, RSHIFT, LSHIFT, TILDE, MODULOEQUAL, ANDEQUAL, XOREQUAL, OREQUAL, LSHIFTEQUAL, RSHIFTEQUAL, ARROW, HASH, ID, NUM, AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, UNSIGNED, VOID, VOLATILE, WHILE, STRING;


globalProg ::= varDeclaration globalProg| funcDeclaration globalProg | funcDeclaration;


varDeclaration ::= CONST type idChain SEMICOLON
                    | type idChain SEMICOLON
                    | CONST type idChain varAsignation SEMICOLON
                    | type idChain varAsignation SEMICOLON;

idChain::= ID COMMA idChain | ID;
type ::= INT | CHAR | LONG | SHORT;
valueType ::= NUM | STRING;

// int a,b = 1,2
// TODO: throw error when id's do not match values ej: a,b = 1;
varAsignation::= ASSIGN asignationChain;
asignationChain::=  valueType COMMA asignationChain | valueType;

funcDeclaration ::= type ID LPAREN paramChain RPAREN LBRACE RBRACE SEMICOLON | VOID ID LPAREN paramChain RPAREN LBRACE RBRACE SEMICOLON ;
paramChain::= type idChain | ;
