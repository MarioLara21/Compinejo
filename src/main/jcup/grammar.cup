import java_cup.runtime.Symbol;
import java_cup.lexer;
import TokenTable.TokenInfo;

parser code {:
    public void report_error(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol sym = (Symbol) info;
            TokenInfo tokenInf = (TokenInfo) sym.value;
            if(!message.equals("Syntax error")){
                System.err.printf("Syntax Error: %s near token %s at line %d, column %d%n",
                        message, tokenInf.value, tokenInf.line, tokenInf.column);
            }
            else{
                System.err.printf("Syntax Error: related with token %s at line %d, column %d%n",
                        tokenInf.value, tokenInf.line, tokenInf.column);
            }

        } else {
            System.err.println("Syntax Error: " + message);
        }
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Fatal error: Unable to continue parsing.");
    }
:};

nonterminal varDeclaration, type, idChain, funcDeclaration, globalProg, varAsignation, asignationChain, paramChain;
nonterminal funcImpl, funcHead, funcBody;
nonterminal arithmeticExpression, statement, booleanExpression, expression;
nonterminal if_statement, for_statement, while_statement, switch_statement;
nonterminal statement_block,case_blocks,read_statement,write_statement;
nonterminal function_call,params,validVarDeclaration,varDeclarationError;

terminal COMMA, SEMICOLON, INCREMENT, DECREMENT, EQUALS, GREATEREQUAL, GREATER, QUESTION, LESSEQUAL, LESS, NOTEQUAL;
terminal OROR, ANDAND, NOT, ASSIGN, PLUS, MINUS, TIMES, DIVIDE, MODULO, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE;
terminal RBRACE, COLON, DOT, PLUSEQUAL, MINUSEQUAL, TIMESEQUAL, DIVIDEEQUAL, AND, XOR, OR, RSHIFT, LSHIFT, TILDE;
terminal MODULOEQUAL, ANDEQUAL, XOREQUAL, OREQUAL, LSHIFTEQUAL, RSHIFTEQUAL, ARROW, HASH, ID, NUM, AUTO, BREAK, CASE;
terminal CHAR, CONST, CONTINUE, DEFAULT, DO, DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER;
terminal RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, UNSIGNED, VOID, VOLATILE, WHILE, STRING;
terminal READ,WRITE;
precedence left OROR;
precedence left ANDAND;
precedence left EQUALS, NOTEQUAL;
precedence left GREATEREQUAL, GREATER, LESSEQUAL, LESS;
precedence left ASSIGN;
precedence left PLUSEQUAL, MINUSEQUAL, TIMESEQUAL, DIVIDEEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO;
precedence right INCREMENT, DECREMENT;
precedence right NOT;  // Highest precedence for NOT

globalProg ::= varDeclaration globalProg| funcDeclaration globalProg | funcDeclaration;


varDeclaration ::= validVarDeclaration
                 | varDeclarationError;

validVarDeclaration ::= CONST type idChain SEMICOLON
                      | type idChain SEMICOLON
                      | CONST type varAsignation SEMICOLON
                      | type varAsignation SEMICOLON;

varDeclarationError ::= CONST type idChain {: parser.report_error("Error: Falta ; al final de la declaracion.", parser.scan()); :}
                      | type idChain {: parser.report_error("Error: Falta ';' al final de la declaracion.", parser.scan()); :}
                      | CONST type varAsignation {: parser.report_error("Error: Falta ';' al final de la declaracion.", parser.scan()); :}
                      | type varAsignation {: parser.report_error("Error: Falta ';' al final de la declaracion.", parser.scan()); :};

idChain::= idChain COMMA ID | ID | error {::};
type ::= INT
        | CHAR
        | LONG
        | SHORT
        | error {:parser.report_error("Invalid type", parser.scan());:};

params ::= ID | NUM | CHAR;
// int a,b = 1,2
// TODO: throw error when id's do not match values ej: a,b = 1;
varAsignation::= idChain ASSIGN asignationChain;
asignationChain::=  NUM COMMA asignationChain | NUM | error {:parser.report_error("Assignation error", parser.scan());:};

funcDeclaration ::= type ID LPAREN paramChain RPAREN LBRACE funcImpl RBRACE
                  | VOID ID LPAREN paramChain RPAREN LBRACE funcImpl RBRACE;

paramChain::= type ID COMMA paramChain | type ID | ;

funcImpl ::= varDeclaration funcImpl | statement funcImpl | statement | error {:parser.report_error("Function implementation error", parser.scan());:};

// Statements can be expressions with semicolons
statement ::= expression SEMICOLON | funcBody | if_statement | for_statement | while_statement | switch_statement | BREAK SEMICOLON | CONTINUE SEMICOLON | write_statement | read_statement | function_call;
statement_block ::= LBRACE funcImpl RBRACE;

read_statement ::= READ LPAREN RPAREN SEMICOLON | READ LPAREN ID RPAREN SEMICOLON;

write_statement ::= WRITE LPAREN expression RPAREN SEMICOLON;

function_call ::= ID LPAREN params RPAREN;

// Top-level expression that can be boolean or arithmetic
expression ::= booleanExpression
             | arithmeticExpression
             | error {:parser.report_error("Invalid expression", parser.scan());:};

// Arithmetic expressions
arithmeticExpression ::= arithmeticExpression PLUS arithmeticExpression
                       | arithmeticExpression MINUS arithmeticExpression
                       | arithmeticExpression TIMES arithmeticExpression
                       | arithmeticExpression DIVIDE arithmeticExpression
                       | arithmeticExpression MODULO arithmeticExpression
                       | arithmeticExpression ASSIGN arithmeticExpression
                       | arithmeticExpression PLUSEQUAL arithmeticExpression
                       | arithmeticExpression MINUSEQUAL arithmeticExpression
                       | arithmeticExpression TIMESEQUAL arithmeticExpression
                       | arithmeticExpression DIVIDEEQUAL arithmeticExpression
                       | ID INCREMENT
                       | ID DECREMENT
                       | INCREMENT ID
                       | DECREMENT ID
                       | NUM
                       | ID
                       | LPAREN arithmeticExpression RPAREN;

// Boolean expressions
booleanExpression ::= arithmeticExpression EQUALS arithmeticExpression
                    | arithmeticExpression NOTEQUAL arithmeticExpression
                    | arithmeticExpression GREATEREQUAL arithmeticExpression
                    | arithmeticExpression GREATER arithmeticExpression
                    | arithmeticExpression LESSEQUAL arithmeticExpression
                    | arithmeticExpression LESS arithmeticExpression
                    | booleanExpression OROR booleanExpression
                    | booleanExpression ANDAND booleanExpression
                    | NOT booleanExpression
                    | LPAREN booleanExpression RPAREN;

case_blocks ::= case_blocks CASE NUM COLON statement
              | case_blocks CASE error COLON statement {:parser.report_error("Error: 'case' debe ser una constante.", parser.scan());:}
              | case_blocks DEFAULT COLON statement
              | DEFAULT COLON statement
              | error {:parser.report_error("Error en 'case' o 'default' en 'switch'.", parser.scan());:};

// If - If_else Statements
if_statement::= IF LPAREN expression RPAREN statement_block SEMICOLON
                | IF LPAREN expression RPAREN statement_block ELSE statement_block SEMICOLON
                | IF LPAREN expression RPAREN statement_block ELSE error {: parser.report_error("Error: Uso duplicado de 'else' en 'if'.", parser.scan()); :};

// For Statements
for_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement_block SEMICOLON;

// While Statements
while_statement ::= WHILE LPAREN expression RPAREN statement_block SEMICOLON;

// Switch Statements
switch_statement ::= SWITCH LPAREN NUM RPAREN LBRACE case_blocks RBRACE SEMICOLON;