nonterminal varDeclaration, type, idChain, funcDeclaration, globalProg, varAsignation, asignationChain, paramChain, funcImpl, funcHead, funcBody;
nonterminal arithmeticExpression, statement, booleanExpression, expression;

terminal COMMA, SEMICOLON, INCREMENT, DECREMENT, EQUALS, GREATEREQUAL, GREATER, QUESTION, LESSEQUAL, LESS, NOTEQUAL, OROR, ANDAND, NOT, ASSIGN, PLUS, MINUS, TIMES, DIVIDE, MODULO, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE, COLON, DOT, PLUSEQUAL, MINUSEQUAL, TIMESEQUAL, DIVIDEEQUAL, AND, XOR, OR, RSHIFT, LSHIFT, TILDE, MODULOEQUAL, ANDEQUAL, XOREQUAL, OREQUAL, LSHIFTEQUAL, RSHIFTEQUAL, ARROW, HASH, ID, NUM, AUTO, BREAK, CASE, CHAR, CONST, CONTINUE, DEFAULT, DO, DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER, RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, UNSIGNED, VOID, VOLATILE, WHILE, STRING;

precedence left OROR;
precedence left ANDAND;
precedence left EQUALS, NOTEQUAL;
precedence left GREATEREQUAL, GREATER, LESSEQUAL, LESS;
precedence left ASSIGN;
precedence left PLUSEQUAL, MINUSEQUAL, TIMESEQUAL, DIVIDEEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO;
precedence right INCREMENT, DECREMENT;
precedence right NOT;  // Highest precedence for NOT

globalProg ::= varDeclaration globalProg| funcDeclaration globalProg | funcDeclaration;


varDeclaration ::= CONST type idChain SEMICOLON
                    | type idChain SEMICOLON
                    | CONST type varAsignation SEMICOLON
                    | type varAsignation SEMICOLON;

idChain::= idChain COMMA ID | ID;
type ::= INT | CHAR | LONG | SHORT;

// int a,b = 1,2
// TODO: throw error when id's do not match values ej: a,b = 1;
varAsignation::= idChain ASSIGN asignationChain;
asignationChain::=  NUM COMMA asignationChain | NUM;

funcDeclaration ::= type ID LPAREN paramChain RPAREN LBRACE funcImpl RBRACE SEMICOLON | VOID ID LPAREN paramChain RPAREN LBRACE funcImpl RBRACE SEMICOLON ;
paramChain::= type ID COMMA paramChain | type ID | ;

funcImpl ::= varDeclaration funcImpl | statement funcImpl | statement;  // `statement` instead of `funcBody`

// Statements can be expressions with semicolons
statement ::= expression SEMICOLON | funcBody | if_statement | for_statement | while_statement | switch_statement | READ LPAREN RPAREN SEMICOLON | WRITE LPAREN expression RPAREN SEMICOLON | BREAK SEMICOLON | CONTINUE SEMICOLON;
statement_block ::= LBRACE funcImpl RBRACE;

// Top-level expression that can be boolean or arithmetic
expression ::= booleanExpression | arithmeticExpression;

// Arithmetic expressions
arithmeticExpression ::= arithmeticExpression PLUS arithmeticExpression
                       | arithmeticExpression MINUS arithmeticExpression
                       | arithmeticExpression TIMES arithmeticExpression
                       | arithmeticExpression DIVIDE arithmeticExpression
                       | arithmeticExpression MODULO arithmeticExpression
                       | arithmeticExpression ASSIGN arithmeticExpression
                       | arithmeticExpression PLUSEQUAL arithmeticExpression
                       | arithmeticExpression MINUSEQUAL arithmeticExpression
                       | arithmeticExpression TIMESEQUAL arithmeticExpression
                       | arithmeticExpression DIVIDEEQUAL arithmeticExpression
                       | ID INCREMENT
                       | ID DECREMENT
                       | INCREMENT ID
                       | DECREMENT ID
                       | NUM
                       | ID
                       | LPAREN arithmeticExpression RPAREN;

// Boolean expressions
booleanExpression ::= arithmeticExpression EQUALS arithmeticExpression
                    | arithmeticExpression NOTEQUAL arithmeticExpression
                    | arithmeticExpression GREATEREQUAL arithmeticExpression
                    | arithmeticExpression GREATER arithmeticExpression
                    | arithmeticExpression LESSEQUAL arithmeticExpression
                    | arithmeticExpression LESS arithmeticExpression
                    | booleanExpression OROR booleanExpression
                    | booleanExpression ANDAND booleanExpression
                    | NOT booleanExpression
                    | LPAREN booleanExpression RPAREN;

// If - If_else Statements
if_statement ::= IF "(" expression ")" statement_block SEMICOLON
                | IF "(" expression ")" statement_block ElSE statement_block SEMICOLON

// For Statements
for_statement ::= FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement_block SEMICOLON

// While Statements
while_statement ::= WHILE LPAREN expression RPAREN statement_block SEMICOLON

// Switch Statements
switch_statement ::= SWITCH LPAREN NUM RPAREN LBRACE case_blocks RBRACE SEMICOLON
