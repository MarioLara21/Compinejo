import java_cup.runtime.Symbol;
import java_cup.lexer;
import TokenTable.TokenInfo;
import java.util.*;

parser code {:
    public void report_error(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol sym = (Symbol) info;
            TokenInfo tokenInf = (TokenInfo) sym.value;
            if(!message.equals("Syntax error")){
                System.err.printf("Syntax Error: %s near token %s at line %d, column %d%n",
                        message, tokenInf.value, tokenInf.line, tokenInf.column);
            }
            else{
                System.err.printf("Syntax Error: related with token %s at line %d, column %d%n",
                        tokenInf.value, tokenInf.line, tokenInf.column);
            }

        } else {
            System.err.println("Syntax Error: " + message);
        }
    }

    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        throw new RuntimeException("Fatal error: Unable to continue parsing.");
    }
:};

nonterminal varDeclaration, type, idChain, funcDeclaration, globalProg, varAsignation, asignationChain, paramChain;
nonterminal funcImpl, funcHead;
nonterminal arithmeticExpression, statement, booleanExpression, expression;
nonterminal if_statement, for_statement, while_statement, switch_statement;
nonterminal statement_block,case_blocks, case_block, default_block,read_statement,write_statement;
nonterminal function_call,params, else_block;

terminal COMMA, SEMICOLON, INCREMENT, DECREMENT, EQUALS, GREATEREQUAL, GREATER, QUESTION, LESSEQUAL, LESS, NOTEQUAL;
terminal OROR, ANDAND, NOT, ASSIGN, PLUS, MINUS, TIMES, DIVIDE, MODULO, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE;
terminal RBRACE, COLON, DOT, PLUSEQUAL, MINUSEQUAL, TIMESEQUAL, DIVIDEEQUAL, AND, XOR, OR, RSHIFT, LSHIFT, TILDE;
terminal MODULOEQUAL, ANDEQUAL, XOREQUAL, OREQUAL, LSHIFTEQUAL, RSHIFTEQUAL, ARROW, HASH, ID, NUM, AUTO, BREAK, CASE;
terminal CHAR, CONST, CONTINUE, DEFAULT, DO, DOUBLE, ELSE, ENUM, EXTERN, FLOAT, FOR, GOTO, IF, INT, LONG, REGISTER;
terminal RETURN, SHORT, SIGNED, SIZEOF, STATIC, STRUCT, SWITCH, TYPEDEF, UNION, UNSIGNED, VOID, VOLATILE, WHILE, STRING;
terminal READ,WRITE;
precedence left OROR;
precedence left ANDAND;
precedence left EQUALS, NOTEQUAL;
precedence left GREATEREQUAL, GREATER, LESSEQUAL, LESS;
precedence left ASSIGN;
precedence left PLUSEQUAL, MINUSEQUAL, TIMESEQUAL, DIVIDEEQUAL;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MODULO;
precedence right INCREMENT, DECREMENT;
precedence right NOT;  // Highest precedence for NOT

globalProg ::= varDeclaration globalProg| funcDeclaration globalProg | funcDeclaration;


varDeclaration ::= CONST type:val1 idChain:val2 SEMICOLON {:
    for(String id: (List<String>)val2){
        System.out.println("const " + val1 + " " + id +";");
    }
:}
                      | type idChain SEMICOLON
                      | CONST type varAsignation SEMICOLON
                      | type varAsignation SEMICOLON;

type ::= INT:type {:RESULT = (String)type; :}
        | CHAR:type {:RESULT = (String)type; :}
        | LONG:type {:RESULT = (String)type; :}
        | SHORT:type {:RESULT = (String)type; :}
        | error {:parser.report_error("Invalid type", parser.scan());:};

params ::= expression | CHAR;
// int a,b = 1,2
// TODO: throw error when id's do not match values ej: a,b = 1;
varAsignation::= idChain ASSIGN asignationChain;

idChain ::= idChain:chain COMMA ID:id
             {:
                // Use chain's result and add the new ID
                ((List<String>)chain).add((String) id);
                RESULT = chain;
             :}
          | ID:id
             {:
                // Create a new list with a single ID
                List<String> ids = new ArrayList<>();
                ids.add((String) id);
                RESULT = ids;
             :};
asignationChain::=  asignationChain COMMA expression
                    | expression
                    | error {:parser.report_error("Assignation error", parser.scan());:};

funcDeclaration ::= type ID LPAREN paramChain RPAREN LBRACE funcImpl RBRACE
                  | VOID ID LPAREN paramChain RPAREN LBRACE funcImpl RBRACE;

paramChain::= type ID COMMA paramChain | type ID | ;

funcImpl ::= varDeclaration funcImpl | statement funcImpl | statement | error {:parser.report_error("Function implementation error", parser.scan());:};

// Statements can be expressions with semicolons
statement ::= expression SEMICOLON
                | if_statement
                | for_statement
                | while_statement
                | switch_statement
                | write_statement
                | read_statement
                | function_call
                | BREAK SEMICOLON
                | CONTINUE SEMICOLON;

statement_block ::= LBRACE funcImpl RBRACE;

read_statement ::= READ LPAREN RPAREN SEMICOLON | READ LPAREN ID RPAREN SEMICOLON | READ LPAREN error RPAREN SEMICOLON {:parser.report_error("Invalid parameters in read", parser.scan());:};

write_statement ::= WRITE LPAREN expression RPAREN SEMICOLON | WRITE LPAREN RPAREN SEMICOLON {:parser.report_error("Invalid parameters in write", parser.scan());:};

function_call ::= ID LPAREN params RPAREN | ID LPAREN RPAREN;

// Top-level expression that can be boolean or arithmetic
expression ::= booleanExpression
             | arithmeticExpression;

// Arithmetic expressions
arithmeticExpression ::= arithmeticExpression PLUS arithmeticExpression
                       | arithmeticExpression MINUS arithmeticExpression
                       | arithmeticExpression TIMES arithmeticExpression
                       | arithmeticExpression DIVIDE arithmeticExpression
                       | arithmeticExpression MODULO arithmeticExpression
                       | arithmeticExpression ASSIGN arithmeticExpression
                       | arithmeticExpression PLUSEQUAL arithmeticExpression
                       | arithmeticExpression MINUSEQUAL arithmeticExpression
                       | arithmeticExpression TIMESEQUAL arithmeticExpression
                       | arithmeticExpression DIVIDEEQUAL arithmeticExpression
                       | ID INCREMENT
                       | ID DECREMENT
                       | INCREMENT ID
                       | DECREMENT ID
                       | NUM
                       | ID
                       | function_call
                       | LPAREN arithmeticExpression RPAREN;

// Boolean expressions
booleanExpression ::= arithmeticExpression EQUALS arithmeticExpression
                    | arithmeticExpression NOTEQUAL arithmeticExpression
                    | arithmeticExpression GREATEREQUAL arithmeticExpression
                    | arithmeticExpression GREATER arithmeticExpression
                    | arithmeticExpression LESSEQUAL arithmeticExpression
                    | arithmeticExpression LESS arithmeticExpression
                    | booleanExpression OROR booleanExpression
                    | booleanExpression ANDAND booleanExpression
                    | NOT booleanExpression
                    | LPAREN booleanExpression RPAREN;


// If - If_else Statements
if_statement::= IF LPAREN expression RPAREN statement_block
                | IF LPAREN expression RPAREN statement_block else_block
                | IF LPAREN expression RPAREN statement_block ELSE error {: parser.report_error("Error: Uso duplicado de 'else' en 'if'.", parser.scan()); :};
// For Statements
for_statement ::=
      FOR LPAREN expression SEMICOLON expression SEMICOLON expression RPAREN statement_block
    | FOR LPAREN error SEMICOLON expression SEMICOLON expression RPAREN statement_block
       {:parser.report_error("For first expression error", parser.scan());:}
    | FOR LPAREN expression SEMICOLON error SEMICOLON expression RPAREN statement_block
      {:parser.report_error("For second expression error", parser.scan());:}
    | FOR LPAREN expression SEMICOLON expression SEMICOLON error RPAREN statement_block
      {:parser.report_error("For third expression error", parser.scan());:}
    | FOR LPAREN expression SEMICOLON expression SEMICOLON expression error
      {:parser.report_error("For body error", parser.scan());:}

    | FOR LPAREN error  RPAREN statement_block
      {:parser.report_error("For expression error", parser.scan());:}

    | FOR error
     {:parser.report_error("For structure error", parser.scan());:};

// While Statements
while_statement ::= WHILE LPAREN expression RPAREN statement_block
                  | WHILE LPAREN RPAREN statement_block {:parser.report_error("While expression can't be empty", parser.scan());:}
                  | WHILE error {:parser.report_error("While structure error", parser.scan());:};

// Switch Statements
switch_statement ::= SWITCH LPAREN arithmeticExpression RPAREN LBRACE case_blocks RBRACE
                    |SWITCH LPAREN error RPAREN LBRACE case_blocks RBRACE {:parser.report_error("Switch structure error", parser.scan());:} ;


case_blocks ::= case_block case_blocks
              | case_block
              | default_block;

// Individual case block
case_block ::= CASE NUM COLON statement_block
             | CASE CHAR COLON statement_block
             | CASE error {:parser.report_error("Case block error", parser.scan());:};

// Default case block
default_block ::= DEFAULT COLON statement_block
                 |DEFAULT error {:parser.report_error("Default block error", parser.scan());:}
                 |DEFAULT COLON statement_block error {:parser.report_error("Only one default is permitted", parser.scan());:};


